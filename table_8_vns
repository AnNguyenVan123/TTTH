import networkx as nx
import random
import math
import numpy as np
from scipy.io import mmread
import sys
import os
import glob
import time

# =====================================================================
# Graph Loading
# =====================================================================

def load_graph_from_mtx(path):
    try:
        M = mmread(path)
        if hasattr(M, 'tocsr'):
            M = M.tocsr()
        if M.dtype not in [np.int32, np.int64, np.float32, np.float64]:
            M.data[:] = 1
        rows, cols = M.shape
        if rows == cols:
            G = nx.from_scipy_sparse_array(M, create_using=nx.Graph)
        else:
            G = nx.bipartite.from_biadjacency_matrix(M)
            G = nx.Graph(G)
        G.remove_edges_from(nx.selfloop_edges(G))
        return G
    except Exception as e:
        print(f"Error loading {path}: {e}")
        return None

# =====================================================================
# Double Roman Domination Solver (GA + ACO + Optimized VNS)
# =====================================================================

class DoubleRomanDomination:
    def __init__(self, graph):
        self.G = graph
        self.nodes = list(graph.nodes())
        self.n = len(self.nodes)
        
        # Pre-calculate degrees for heuristic performance
        self.degrees = dict(graph.degree())

        # ACO Parameters
        self.ACO_PARAMS = {
            'num_constructions': 5, 'rho': 0.2, 'd_rate': 0.9, 'd_rate_aco': 0.7, 
            'd_min': 0.2, 'd_max': 0.5, 'r_aug': 0.05, 'k_max': 5, 
            'rvns_max_itr': 150, 'max_noimpr': 10
        }

    def calculate_weight(self, solution):
        return sum(solution.values())

    def is_feasible(self, solution):
        for u in self.nodes:
            label = solution.get(u, 0)
            neighbors = [solution.get(v, 0) for v in self.G.neighbors(u)]
            if label == 0:
                has_3 = any(l == 3 for l in neighbors)
                count_2 = sum(1 for l in neighbors if l == 2)
                if not has_3 and count_2 < 2: return False
            elif label == 1:
                if not any(l >= 2 for l in neighbors): return False
        return True

    def feasibility_repair(self, solution):
        new_sol = solution.copy()
        for u in self.nodes:
            if new_sol[u] == 0:
                if not any(new_sol[v] == 3 for v in self.G.neighbors(u)):
                    new_sol[u] = 2
        return new_sol

    # ==================== Shared Heuristics ====================

    def heuristic_1(self):
        S = {u: 0 for u in self.nodes}
        V_prime = set(self.nodes)
        while V_prime:
            u = random.choice(list(V_prime))
            S[u] = 3
            V_prime -= set(self.G.neighbors(u)) | {u}
            if len(V_prime) == 1:
                S[list(V_prime)[0]] = 2; V_prime.clear()
        return S

    def heuristic_2(self):
        S = {u: 0 for u in self.nodes}
        V_prime = set(self.nodes)
        while V_prime:
            u = random.choice(list(V_prime))
            S[u] = 3
            V_prime -= set(self.G.neighbors(u)) | {u}
            to_remove = [v for v in V_prime if sum(1 for n in self.G.neighbors(v) if n in V_prime) == 0]
            for v in to_remove: S[v] = 2; V_prime.remove(v)
        return S

    def heuristic_3(self):
        S = {u: 0 for u in self.nodes}
        V_prime = set(self.nodes)
        while V_prime:
            cand = list(V_prime)
            if not cand: break
            # Find nodes with max degree in static graph
            max_deg = max(self.degrees[v] for v in cand)
            best_cand = [v for v in cand if self.degrees[v] == max_deg]
            u = random.choice(best_cand)
            S[u] = 3
            V_prime -= set(self.G.neighbors(u)) | {u}
            to_remove = [v for v in V_prime if sum(1 for n in self.G.neighbors(v) if n in V_prime) == 0]
            for v in to_remove: S[v] = 2; V_prime.remove(v)
        return S

    # ==================== GA Implementation ====================

    def tournament_selection(self, pop, k=3):
        return min(random.sample(pop, k), key=self.calculate_weight)

    def roulette_wheel_selection(self, pop):
        costs = [self.calculate_weight(s) for s in pop]
        fits = [1.0 / (c + 1e-9) for c in costs]
        pick = random.uniform(0, sum(fits))
        curr = 0
        for s, f in zip(pop, fits):
            curr += f
            if curr > pick: return s
        return pop[-1]

    def ga_crossover(self, S1, S2):
        if self.n < 2: return S1
        idx1, idx2 = sorted(random.sample(range(self.n), 2))
        c1, c2 = S1.copy(), S2.copy()
        nodes = self.nodes
        for i in range(idx1, idx2):
            u = nodes[i]
            c1[u], c2[u] = c2[u], c1[u]
        c1, c2 = self.feasibility_repair(c1), self.feasibility_repair(c2)
        return c1 if self.calculate_weight(c1) < self.calculate_weight(c2) else c2

    def run_genetic_algorithm(self, iterations=100, pop_size=100):
        if self.n == 0: return 0
        pop = []
        pop.extend([self.heuristic_1() for _ in range(int(pop_size*0.4))])
        pop.extend([self.heuristic_2() for _ in range(int(pop_size*0.4))])
        while len(pop) < pop_size: pop.append(self.heuristic_3())
        
        best = min(pop, key=self.calculate_weight)
        for _ in range(iterations):
            new_pop = []
            while len(new_pop) < pop_size:
                p1 = self.tournament_selection(pop)
                p2 = self.roulette_wheel_selection(pop)
                new_pop.append(self.ga_crossover(p1, p2))
            pop = new_pop
            curr_best = min(pop, key=self.calculate_weight)
            if self.calculate_weight(curr_best) < self.calculate_weight(best):
                best = curr_best.copy()
        return self.calculate_weight(best)

    # ==================== Optimized VNS (Standalone) ====================

    def vns_reduce(self, S):
        """Greedy reduction: Try to lower labels from 3->0 or 2->0"""
        # Sort nodes by degree desc to try reducing hubs first (or leaves? usually hubs first is safer for 3->0)
        sorted_nodes = sorted(self.nodes, key=lambda x: self.degrees[x], reverse=True)
        for u in sorted_nodes:
            if S[u] in [2, 3]:
                original = S[u]
                S[u] = 0
                if not self.is_feasible(S):
                    S[u] = 2 # Try downgrading to 2
                    if not self.is_feasible(S):
                        S[u] = original # Revert
        return S

    def vns_shake(self, S, k):
        """Perturbation: Remove k random dominators and repair greedily"""
        S_new = S.copy()
        dominators = [u for u in self.nodes if S_new[u] in [2, 3]]
        if not dominators: return S_new
        
        # 1. Destroy: Remove k random dominators
        k_actual = min(len(dominators), k)
        targets = random.sample(dominators, k_actual)
        for u in targets:
            S_new[u] = 0
            
        # 2. Repair (Greedy Degree based, NO Pheromones)
        # Check infeasibility
        infeasible_nodes = []
        for u in self.nodes:
            # Simple check logic inline for speed
            neighs = self.G.neighbors(u)
            has_3 = False
            count_2 = 0
            for v in neighs:
                val = S_new.get(v, 0)
                if val == 3: 
                    has_3 = True; break
                if val == 2: count_2 += 1
            
            label = S_new.get(u, 0)
            if label == 0:
                if not has_3 and count_2 < 2:
                    infeasible_nodes.append(u)
        
        # Fill holes with highest degree neighbors
        for u in infeasible_nodes:
            # If still infeasible after previous updates
            neighs = list(self.G.neighbors(u))
            # Check status again
            l_vals = [S_new.get(v,0) for v in neighs]
            if not any(l==3 for l in l_vals) and sum(1 for l in l_vals if l==2) < 2:
                # Need to fix u. Best strategy: make u itself a 2, or make a high-degree neighbor 3?
                # Making a high-degree neighbor 3 covers more ground.
                best_n = max(neighs + [u], key=lambda x: self.degrees[x])
                S_new[best_n] = 3
                
        return self.feasibility_repair(S_new) # Final safety check

    def run_vns_standalone(self, max_iter=300, k_max=10, max_no_impr=50):
        """
        Standalone VNS with optimal tuning.
        Initialization: Heuristic 3 (Best heuristic)
        Strategy: Shake -> Repair -> Reduce
        """
        if self.n == 0: return 0
        
        # Initialize with the best heuristic
        current_sol = self.heuristic_3()
        current_sol = self.vns_reduce(current_sol)
        best_sol = current_sol.copy()
        best_weight = self.calculate_weight(best_sol)
        
        k = 1
        no_impr_count = 0
        
        for _ in range(max_iter):
            # 1. Shake
            shaken_sol = self.vns_shake(current_sol, k)
            
            # 2. Local Search (Reduction is our main local search here)
            local_sol = self.vns_reduce(shaken_sol)
            local_weight = self.calculate_weight(local_sol)
            
            # 3. Move or Stay
            if local_weight < best_weight:
                best_sol = local_sol.copy()
                best_weight = local_weight
                current_sol = local_sol.copy()
                k = 1
                no_impr_count = 0
            else:
                k += 1
                no_impr_count += 1
                
            if k > k_max: 
                k = 1
                # If stuck at k_max, maybe drift a bit?
                current_sol = local_sol # Accept equal or worse to escape? Standard VNS says no, but GVNS might.
                
            if no_impr_count >= max_no_impr:
                break
                
        return best_weight

    # ==================== ACO Implementation ====================

    def choose_vertex_aco(self, V_prime, pheromones, is_construct):
        rate = self.ACO_PARAMS['d_rate_aco'] if is_construct else self.ACO_PARAMS['d_rate']
        if random.random() <= rate:
            return max(V_prime, key=lambda u: self.degrees[u] * pheromones.get(u, 0.5))
        
        total = sum(self.degrees[u] * pheromones.get(u, 0.5) for u in V_prime)
        if total == 0: return random.choice(list(V_prime))
        pick = random.uniform(0, total)
        curr = 0
        for u in V_prime:
            curr += self.degrees[u] * pheromones.get(u, 0.5)
            if curr > pick: return u
        return list(V_prime)[-1]

    def run_aco_table_8(self):
        # Simplified ACO runner for comparison
        if self.n == 0: return (0, 0, 0)
        pheromones = {u: 0.5 for u in self.nodes}
        best_w = float("inf")
        res = {}
        
        for it in range(20):
            iter_best_sol = None
            iter_best_w = float("inf")
            for _ in range(self.ACO_PARAMS['num_constructions']):
                # Construct
                S = {u: 0 for u in self.nodes}
                V = set(self.nodes)
                while V:
                    u = self.choose_vertex_aco(V, pheromones, True)
                    S[u] = 3
                    V -= set(self.G.neighbors(u)) | {u}
                
                # Internal VNS (ACO's local search)
                # Note: Using the standalone reduce logic here for consistency in power
                S = self.vns_reduce(S) 
                
                w = self.calculate_weight(S)
                if w < iter_best_w:
                    iter_best_w = w
                    iter_best_sol = S.copy()
            
            if iter_best_w < best_w:
                best_w = iter_best_w
                best_sol = iter_best_sol
            
            # Pheromone Update
            w_curr = iter_best_w
            for u in self.nodes:
                delta = (1.0 if best_sol[u]==3 else 0)*best_w + (1.0 if iter_best_sol[u]==3 else 0)*w_curr
                delta /= (best_w + w_curr)
                pheromones[u] = (1-0.2)*pheromones[u] + 0.2*delta
                
            if it in [0, 9, 19]:
                res[str(it+1)] = best_w
                
        return res.get('1',0), res.get('10',0), res.get('20',0)

# =====================================================================
# Main Execution
# =====================================================================

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--data_folder", type=str, default="data")
    parser.add_argument("--ga_iter", type=int, default=100)
    parser.add_argument("--ga_pop", type=int, default=100)
    args = parser.parse_args()

    files = sorted(glob.glob(os.path.join(args.data_folder, "*.mtx")))
    if not files:
        print("No .mtx files found.")
        sys.exit(1)

    print("\nCOMPARISON: GA vs ACO vs Optimized VNS")
    print("-" * 105)
    print(f"{'Graph':<20} | {'Nodes':<5} | {'GA (Ref)':<8} | {'ACO(20)':<8} | {'VNS (Opt)':<9} | {'Time(VNS)':<9}")
    print("-" * 105)

    for f in files:
        G = load_graph_from_mtx(f)
        if not G: continue
        
        solver = DoubleRomanDomination(G)
        
        # 1. GA
        ga_res = solver.run_genetic_algorithm(args.ga_iter, args.ga_pop)
        
        # 2. ACO (Last Iteration)
        _, _, aco_20 = solver.run_aco_table_8()
        
        # 3. Optimized VNS
        start_vns = time.time()
        # Tuning: 300 iterations, k_max=10, stop early if no improve after 50
        vns_res = solver.run_vns_standalone(max_iter=300, k_max=10, max_no_impr=50)
        time_vns = time.time() - start_vns

        print(f"{os.path.basename(f):<20} | {G.number_of_nodes():<5} | "
              f"{ga_res:<8} | {aco_20:<8} | {vns_res:<9} | {time_vns:.4f}s")

    print("-" * 105)